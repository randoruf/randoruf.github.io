---
layout: post
title: 'Convex Hull and Suburbs'
date: 2025-06-29
tags: [convex_hull, algorithms]
---

* TOC 
{:toc}

---

## What is Convex Hull ?

> ***Materials to read: ***
> 
> OI Wiki - 凸包 <https://oi-wiki.org/geometry/convex-hull/>
> 
> Convex Hull - USACO Guide <https://usaco.guide/plat/convex-hull?lang=cpp>
> 
> Convex Hull Algorithm - Graham Scan and Jarvis March tutorial <https://www.youtube.com/watch?v=B2AJoQSZf4M>
> 
> 算法学习笔记(64): 极角排序 - <https://zhuanlan.zhihu.com/p/338272449>

## Solutions to Convex Hull

### Graham Scan Algorithm 

The following code is generated by Cursor (AI copilt). 

```python 
def cross(o, a, b):
    # 计算叉积，用于判断转向
    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])

def graham_scan(points):
    if len(points) < 3:
        return points
    # 1. 找到 y 最小的点（如果有多个，取 x 最小的）
    points = sorted(points, key=lambda x: [x[1], x[0]])
    start = points[0]
    # 2. 按极角排序
    def polar(p):
        return np.arctan2(p[1] - start[1], p[0] - start[0])
    sorted_points = [start] + sorted(points[1:], key=polar)
    # 3. Graham扫描
    hull = []
    for p in sorted_points:
        while len(hull) >= 2 and cross(hull[-2], hull[-1], p) <= 0:
            hull.pop()
        hull.append(p)
    return hull
```

With step by step visulization (yielding the results). 

```python
import random
import matplotlib.pyplot as plt
import numpy as np

def generate_points(n, seed=42):
    random.seed(seed)
    return [(random.randint(0, 100), random.randint(0, 100)) for _ in range(n)]

def cross(o, a, b):
    # 叉积
    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])

def graham_scan(points):
    # 1. 找到起点
    points = sorted(points, key=lambda x: [x[1], x[0]])
    start = points[0]

    # 2. 极角排序
    def polar(p):
        return np.arctan2(p[1] - start[1], p[0] - start[0])
    sorted_points = [start] + sorted(points[1:], key=polar)
    # 3. 扫描
    hull = []
    for p in sorted_points:
        while len(hull) >= 2 and cross(hull[-2], hull[-1], p) <= 0:
            hull.pop()
        hull.append(p)
        yield hull, sorted_points  # 每一步都 yield，方便可视化
    return hull

def visualize(points):
    plt.figure(figsize=(8,8))
    plt.scatter(*zip(*points), color='blue')
    plt.title("Random Points")
    plt.show()

    # 动态可视化
    plt.ion()
    fig, ax = plt.subplots(figsize=(8,8))
    ax.scatter(*zip(*points), color='blue')
    for hull, _ in graham_scan(points):
        ax.clear()
        ax.scatter(*zip(*points), color='blue')
        hx, hy = zip(*hull)
        ax.plot(hx, hy, 'r-', lw=2)
        if len(hull) > 1:
            ax.plot([hx[-1], hx[0]], [hy[-1], hy[0]], 'r--', lw=1)  # 闭合
        plt.pause(0.5)
    plt.ioff()
    plt.show()

if __name__ == "__main__":
    points = generate_points(30)
    visualize(points)
```

## Datasets 

Each suburb is represented by a set of geographic coordinates (latitude and longitude) defining its boundaries. These points are then used to construct the convex hull. 

<https://github.com/aidanmorgan/aus_suburb_kml/tree/master>

The backup git repository: 

<https://github.com/randoruf/aus_suburb_kml>

For example, in Clayton suburb: 

<https://github.com/randoruf/aus_suburb_kml/blob/master/VIC/CLAYTON.kml>

The first coordinate is `145.123481152,-37.9050731576`, each pair is seperated by a blank space. 


